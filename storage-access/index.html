<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Storage Access API Embedded Tester Site B</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; line-height: 1.45; margin: 0; padding: 18px; }
    h1,h2 { margin: 0 0 10px 0; }
    p { margin: 8px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
    .card { border: 1px solid rgba(127,127,127,0.28); border-radius: 14px; padding: 12px; margin: 12px 0; background: rgba(127,127,127,0.06); }
    .warn { border-color: rgba(200,140,0,0.8); }
    .ok { border-color: rgba(0,160,0,0.7); }
    .no { border-color: rgba(200,0,0,0.7); }
    button {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(127,127,127,0.35);
      background: rgba(127,127,127,0.12);
      color: inherit;
      cursor: pointer;
    }
    button:hover { background: rgba(127,127,127,0.18); }
    pre { padding: 12px; border-radius: 10px; overflow: auto; background: rgba(127,127,127,0.14); margin: 0; }
    .small { opacity: 0.85; }
  </style>
</head>
<body>
  <h1 id="title">Storage Access API Embedded Tester Site B</h1>

  <div class="card" id="primaryStatus"><b>Loading.</b></div>

  <div class="card" id="warningCard" style="display:none;"></div>

  <div class="card" id="explain"></div>

  <div class="card" id="actionCard" style="display:none;">
    <button id="run">Run test</button>
    <div class="small">
      This calls <span class="mono">document.requestStorageAccess()</span> if supported, then rechecks visibility of the seeded token.
    </div>
  </div>

  <div class="card">
    <pre id="out"></pre>
  </div>

  <script>
    function main() {
      const ORIGIN_A = "https://test-website-a.pages.dev";

      const outEl = document.getElementById("out");
      const primaryEl = document.getElementById("primaryStatus");
      const explainEl = document.getElementById("explain");
      const actionCard = document.getElementById("actionCard");
      const warningCard = document.getElementById("warningCard");

      function post(type, payload) {
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({ type, ...payload }, ORIGIN_A);
          }
        } catch {}
      }

      function line(s) {
        outEl.textContent += s + "\n";
        post("line", { line: s });
      }

      function setPrimary(message, ok) {
        primaryEl.className = "card " + (ok ? "ok" : "no");
        primaryEl.innerHTML = "<b>" + message + "</b>";
        post("status", { message });
      }

      function setPrimaryWarn(message) {
        primaryEl.className = "card warn";
        primaryEl.innerHTML = "<b>" + message + "</b>";
        post("status", { message });
      }

      function cookieMap() {
        const out = {};
        const raw = document.cookie || "";
        raw.split(";").map(s => s.trim()).filter(Boolean).forEach(pair => {
          const i = pair.indexOf("=");
          const k = i >= 0 ? pair.slice(0, i) : pair;
          const v = i >= 0 ? pair.slice(i + 1) : "";
          out[decodeURIComponent(k)] = decodeURIComponent(v);
        });
        return out;
      }

      function setCookie(name, value) {
        document.cookie =
          encodeURIComponent(name) + "=" + encodeURIComponent(value) +
          "; Path=/; Max-Age=31536000; SameSite=None; Secure";
      }

      function randHex(nBytes) {
        try {
          const a = new Uint8Array(nBytes);
          crypto.getRandomValues(a);
          return Array.from(a).map(x => x.toString(16).padStart(2, "0")).join("");
        } catch {
          return Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2);
        }
      }

      function lsGet(k) {
        try { return { ok: true, v: localStorage.getItem(k) }; }
        catch (e) { return { ok: false, err: (e?.name || "Error") + ": " + (e?.message || String(e)) }; }
      }

      function lsSet(k, v) {
        try { localStorage.setItem(k, v); return { ok: true }; }
        catch (e) { return { ok: false, err: (e?.name || "Error") + ": " + (e?.message || String(e)) }; }
      }

      async function hasStorageAccess() {
        if (typeof document.hasStorageAccess !== "function") return { supported: false, value: null, error: null };
        try { return { supported: true, value: await document.hasStorageAccess(), error: null }; }
        catch (e) { return { supported: true, value: null, error: (e?.name || "Error") + ": " + (e?.message || String(e)) }; }
      }

      async function hasUnpartitionedCookieAccess() {
        if (typeof document.hasUnpartitionedCookieAccess !== "function") return { supported: false, value: null, error: null };
        try { return { supported: true, value: await document.hasUnpartitionedCookieAccess(), error: null }; }
        catch (e) { return { supported: true, value: null, error: (e?.name || "Error") + ": " + (e?.message || String(e)) }; }
      }

      function dumpObj(o) { return JSON.stringify(o, null, 2); }

      async function snapshot(label, expectedToken) {
        const supported = {
          hasStorageAccess: typeof document.hasStorageAccess === "function",
          requestStorageAccess: typeof document.requestStorageAccess === "function",
          hasUnpartitionedCookieAccess: typeof document.hasUnpartitionedCookieAccess === "function",
        };

        const hsa = await hasStorageAccess();
        const huca = await hasUnpartitionedCookieAccess();
        const cookies = cookieMap();

        const fpCookie = cookies["saa_fp_cookie"] || "";
        const fpToken = lsGet("saa_fp_token");

        const fpCookieMatches = expectedToken ? fpCookie === expectedToken : Boolean(fpCookie);
        const fpTokenMatches = expectedToken && fpToken.ok ? fpToken.v === expectedToken : (fpToken.ok && Boolean(fpToken.v));

        const visibleAny = Boolean(fpCookie) || (fpToken.ok && Boolean(fpToken.v));
        const matchesAny = fpCookieMatches || fpTokenMatches;

        return {
          label,
          supported,
          hasStorageAccess: hsa,
          hasUnpartitionedCookieAccess: huca,
          fpCookieVisible: Boolean(fpCookie),
          fpLocalStorageVisible: fpToken.ok && Boolean(fpToken.v),
          fpCookieValue: fpCookie,
          fpLocalStorageValue: fpToken.ok ? fpToken.v : null,
          fpLocalStorageError: fpToken.ok ? null : fpToken.err,
          expectedToken: expectedToken || null,
          expectedTokenProvided: Boolean(expectedToken),
          visibleAny,
          matchesAny,
          rawCookie: document.cookie || ""
        };
      }

      function classify(before, after, req, ctx) {
        const apiSupported =
          (typeof document.requestStorageAccess === "function") ||
          (typeof document.hasStorageAccess === "function");

        const seedVisibleBefore = before.expectedTokenProvided ? before.matchesAny : before.visibleAny;
        const seeded = ctx.seedConfirmed || seedVisibleBefore;

        if (!seeded) {
          return { code: "SETUP_MISSING", ok: false, message: "Seed step not completed." };
        }

        if (!apiSupported) {
          return { code: "UNSUPPORTED", ok: false, message: "Storage Access API unsupported." };
        }

        if (seedVisibleBefore) {
          return { code: "ALREADY_AVAILABLE", ok: true, message: "Third party cookies are already enabled, storage access API not needed." };
        }

        if (!req || !req.attempted) {
          return { code: "READY", ok: false, message: "Ready." };
        }

        if (req.ok === false) {
          const n = req.errorName || "";
          if (n === "SecurityError") {
            return { code: "BLOCKED", ok: false, message: "Storage access request blocked by embedding context." };
          }
          if (n === "NotAllowedError" || n === "PermissionDeniedError") {
            return { code: "DENIED", ok: false, message: "Storage Access API permission denied." };
          }
          return { code: "DENIED", ok: false, message: "Storage Access API permission denied." };
        }

        const seedVisibleAfter = before.expectedTokenProvided ? after.matchesAny : after.visibleAny;
        const flipped = !seedVisibleBefore && seedVisibleAfter;

        if (flipped) {
          return { code: "GRANTED_WORKED", ok: true, message: "Storage access granted and first party state became visible." };
        }

        return { code: "GRANTED_NO_EFFECT", ok: false, message: "Storage access granted but no new first party state was observed." };
      }

      async function runFullTest(expectedToken, ctx) {
        outEl.textContent = "";
        line("[" + new Date().toISOString() + "] starting test");

        const before = await snapshot("before", expectedToken);
        line(dumpObj(before));

        let req = { attempted: true, ok: null, errorName: null, errorMessage: null };
        if (typeof document.requestStorageAccess !== "function") {
          req.ok = false;
          req.errorName = "UnsupportedError";
          req.errorMessage = "requestStorageAccess not available";
        } else {
          try {
            line("Calling document.requestStorageAccess()");
            await document.requestStorageAccess();
            req.ok = true;
            line("requestStorageAccess resolved");
          } catch (e) {
            req.ok = false;
            req.errorName = e?.name || "Error";
            req.errorMessage = e?.message || String(e);
            line("requestStorageAccess rejected " + req.errorName + ": " + req.errorMessage);
          }
        }

        const after = await snapshot("after", expectedToken);
        line(dumpObj(after));

        const status = classify(before, after, req, ctx);
        setPrimary(status.message, status.ok);

        post("summary", { summary: { status, before, after, request: req, context: ctx } });
      }

      const inIframe = window.top !== window.self;
      const params = new URLSearchParams(location.search);

      const expectedToken = params.get("expectedToken") || "";
      const seedConfirmed = params.get("seedConfirmed") === "1";
      const sharedHosting = params.get("sharedHosting") === "1";

      if (sharedHosting) {
        warningCard.style.display = "block";
        warningCard.className = "card warn";
        warningCard.innerHTML =
          "<b>Context warning</b>" +
          "<div class='small'>This embed uses pages.dev for both sites. Many engines treat this as same site. Storage Access API is designed for cross site embeds.</div>";
      }

      explainEl.innerHTML =
        "<h2>How results are determined</h2>" +
        "<p>The seed page sets cookie <span class='mono'>saa_fp_cookie</span> and localStorage <span class='mono'>saa_fp_token</span> in a top level Site B tab.</p>" +
        "<p>The embedded test checks whether that exact token is visible before and after calling <span class='mono'>document.requestStorageAccess()</span>.</p>";

      if (!inIframe && params.get("seed") === "1") {
        const openerOrigin = params.get("openerOrigin") || "";
        const tokenFromQuery = params.get("token");
        const token = tokenFromQuery ? String(tokenFromQuery) : randHex(16);
        const t = new Date().toISOString();

        const ls1 = lsSet("saa_fp_token", token);
        setCookie("saa_fp_cookie", token);
        lsSet("saa_fp_seed_time", t);
        setCookie("saa_fp_seed_time", t);

        document.getElementById("title").textContent = "Storage Access API Seed Page Site B";
        setPrimary("Seed complete.", true);

        line("Seeded first party state on Site B.");
        if (!ls1.ok) line("localStorage write error " + ls1.err);

        (async () => {
          const s = await snapshot("top_level_seed_page", token);
          line(dumpObj(s));
        })();

        try {
          if (window.opener && openerOrigin) {
            window.opener.postMessage({ type: "seedComplete", token }, openerOrigin);
          }
        } catch {}

        actionCard.style.display = "none";
        return;
      }

      if (inIframe && params.get("embed") === "1") {
        document.getElementById("title").textContent = "Storage Access API Embedded Test Page Site B";
        actionCard.style.display = "block";

        const ctx = { seedConfirmed, sharedHosting };

        document.getElementById("run").addEventListener("click", () => runFullTest(expectedToken, ctx));

        (async () => {
          const before = await snapshot("initial", expectedToken);
          const status = classify(before, before, null, ctx);
          if (status.code === "READY") setPrimaryWarn("Ready.");
          else setPrimary(status.message, status.ok);

          post("summary", { summary: { status, before, after: null, request: null, context: ctx } });
        })();

        return;
      }

      setPrimaryWarn("Open this page with seed query to seed state.");
      line("Use ?seed=1 to seed first party state.");
    }

    try {
      main();
    } catch (e) {
      const msg = (e?.name || "Error") + ": " + (e?.message || String(e));
      document.getElementById("primaryStatus").className = "card no";
      document.getElementById("primaryStatus").innerHTML = "<b>JavaScript error.</b><div class='small mono'>" + msg + "</div>";
      document.getElementById("out").textContent = e?.stack ? String(e.stack) : msg;
      console.error(e);
    }
  </script>
</body>
</html>

